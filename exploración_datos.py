# -*- coding: utf-8 -*-
"""Exploración_Datos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h06_u2rm-99w-ZRfJA_1TIOenZ9oRQxQ
"""

from google.colab import drive
drive.mount('/content/drive')

"""***LIBRERÍAS***"""

# Importar librerías
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""***BASE DE DATOS***"""

# Subir bases de datos
df_train = pd.read_csv('/content/drive/MyDrive/Modulo final 3 /Bases de datos/bases_unidas.csv')

df_train.head()

"""***PREPROCESAMIENTO Y LIMPIEZA***"""

# Revisión de nulos
df_train.isnull().sum()

# Rellenar valores NaN
df_train['StoreType'].fillna(0, inplace=True)
df_train['Assortment'].fillna(0, inplace=True)
df_train['Promo2'].fillna(0, inplace=True)
df_train.head()

# Rellenar valores NaN
df_train['CompetitionDistance'].fillna(df_train['CompetitionDistance'].mean(), inplace=True)
df_train['Promo2SinceWeek'].fillna(0, inplace=True)
df_train['Promo2SinceYear'].fillna(0, inplace=True)
df_train['PromoInterval'].fillna(0, inplace=True)
df_train.head()

"""**Decidimos unir las columnas de "CompetitionOpenSinceMonth" y "CompetitionOpenSinceYear" en una sola columna llamada "CompetitionOpenSince"  para analizar como la competencia impacta las tiendas en diferentes periodos, facilitando su análisis. Por otra parte, para el manejo de datos faltantes se reemplazo el 0 por una fecha arbitraria, evitando que tanto los datos nulos o ceros interfieran en un análisis posterior. En el momento decidimos mantenerla como un Placeholder por conveniencia pero el tratamiento de datos faltantes puede ser modificado según sea necesario.**

"""

# Crear la columna 'CompetitionOpenSince' directamente, reemplazando "0" por una fecha arbitraria
if 'CompetitionOpenSinceYear' in df_train.columns and 'CompetitionOpenSinceMonth' in df_train.columns:
    df_train['CompetitionOpenSince'] = df_train.apply(
        lambda row: pd.to_datetime(f"{int(row['CompetitionOpenSinceYear'])}-{int(row['CompetitionOpenSinceMonth'])}", format='%Y-%m', errors='coerce')
        if row['CompetitionOpenSinceYear'] > 0 and row['CompetitionOpenSinceMonth'] > 0
        else pd.Timestamp('2000-01-01'), axis=1
    )

df_train.head()

# Definimos la columna Date de forma correcta
df_train['Date'] = pd.to_datetime(df_train['Date'])
df_train.info()
# Convertir la columna a formato 'YYYY-MM'
df_train['CompetitionOpenSince'] = pd.to_datetime(df_train['CompetitionOpenSince'], format='%Y-%m')

# Se elimina las columnas 'CompetitionOpenSinceMonth', 'CompetitionOpenSinceYear', debido a la creacion de la columna CompetitionOpenSince y PromoInterval, ya que no la haremos parte de nuestro analisis
df_train.drop(columns=['CompetitionOpenSinceMonth', 'CompetitionOpenSinceYear'], inplace=True)
df_train.head()

"""**Eliminamos las tiendas cerradas ya que no teníamos datos de ventas, que es nuestro objetivo de análisis, filtramos los datos de la competencia a partir del año 2013 por la relevancia en los datos y evitar el ruido de los años anteriores y así buscar una mejor precisión en el análisis.**  """

# Elimnar tiendas cerradas
df_train = df_train[ df_train.Open == 1 ].copy()

# Convertir la columna a formato 'YYYY-MM'
df_train['CompetitionOpenSince'] = pd.to_datetime(df_train['CompetitionOpenSince'], format='%Y-%m')

# Filtrar datos a partir del año 2013
df_filtro = df_train[df_train['CompetitionOpenSince'].dt.year >= 2013]
df_filtro.head()

"""***ANÁLISIS ESTADÍSTICO - EXPLORATORIO***"""

# Verificación de columnas
df_filtro.columns

# 1. Scatter plot para ver la relación entre Ventas y Clientes
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Customers', y='Sales', data=df_train, color='red')
plt.title('Relación entre Ventas y Clientes')
plt.xlabel('Clientes')
plt.ylabel('Ventas')
plt.show()

"""**Se evidencia una relación positiva entres las dos varibles, pero debido a la disperción se puede decir que existen otros factores que afectan el volumen de ventas.**"""

# 2. Histograma para la variable Ventas (Sales)
plt.figure(figsize=(10, 6))
sns.histplot(df_train['Sales'], bins=30, kde=True, color='blue')
plt.title('Distribución de Ventas')
plt.xlabel('Ventas')
plt.ylabel('Frecuencia')
plt.show()

"""**La gráfica campana nos indica una inclinación hacia la derecha, mostrando así que la mayoría de ventas se concentran en valores más bajos, mientras que un menor nímero de ventas alcanzan valores más altos, esto se puede dar por la gestión del mercado como el surtido o las promociones.**"""

# 3. Agrupar las ventas totales por día de la semana
sales_by_day = df_train.groupby('DayOfWeek')['Sales'].sum().reset_index()
sns.set(style="whitegrid")
plt.figure(figsize=(10, 6))
sns.barplot(x='DayOfWeek', y='Sales', data=sales_by_day, palette="muted")
plt.title('Ventas Totales por Día de la Semana', fontsize=16, fontweight='bold')
plt.xlabel('Día de la Semana', fontsize=12)
plt.ylabel('Ventas Totales', fontsize=12)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.tight_layout()
plt.show()

"""**Observamos que los días lunes, 
martes y viernes se presenta un mayor volumen de ventas, lo que nos puede indicar que los clientes buscan abastecerse para la semana, 
el día Domingo muestra menos ventas por que las tiendas no abren todos los domingos solo algunas fechas, teniendo en cuenta los días más altos en ventas 
son los lunes, martes y viernes, se podrían realizar promociones para aprovechar el flujo de clientes, se podria considerar implementar ofertas llamativas
 para el día miércoles y jueves y abrir mirar si es viable abrir más regularmente los días domingos.**"""

# 4. Clientes a lo largo del tiempo por tipo de tienda agrupado por año
sns.set(style="whitegrid")
plt.figure(figsize=(12, 6))
sns.lineplot(x='Date', y='Customers', hue='StoreType', data=df_filtro,
             palette='muted', marker='o', linewidth=2)
plt.title('Clientes a lo largo del tiempo por tipo de tienda', fontsize=16, fontweight='bold')
plt.ylabel('Número de Clientes', fontsize=12)
plt.xlabel('Año', fontsize=12)
plt.xticks(rotation=45)

plt.legend(title='Tipo de Tienda', loc='upper left', bbox_to_anchor=(1, 1))

plt.tight_layout()

"""**Clientes a lo largo del tiempo por tiendas:**
**Se sugiere que el número de cliente se mantiene estable a lo largo del tiempo, manteniendoce constante, las tiendas parecen tener una segmentación diferente por lo cual podría atraer un tipo específico de clientes, la tienda (B) representa un mayor número de clientes a diferencia de la (A,C Y D ), lo cual nos podría indicar una oportunidad de mejora en su oferta de productos, fidelización de clientes y visibilidad en el mercado.**
"""

# 5. Crear una columna de período 'YYYY-MM' para la gráfica
df_filtro['YearMonth'] = df_filtro['Date'].dt.to_period('M')

# Calcular ventas promedio mensual
monthly_sales = df_filtro.groupby('YearMonth')['Sales'].sum()

plt.figure(figsize=(14, 7))
monthly_sales.plot(marker='o')
plt.title('Ventas Totales Mensuales desde 2013')
plt.xlabel('Mes')
plt.ylabel('Ventas Totales')
plt.grid(True)
plt.show()

"""**Se evidencia picos significativos de ventas a inicio de cada año en Enero de 2014 y 2015, esto lo relacionamos a los eventos estacionales como puede ser navidad o año nuevo debido al consumo de esas fechas, despues de estas fecha de alta demanda se nota una estabilizacion de las ventas siendo más bajos entre Marzo y Abril, lo cual se puede deber a una baja temporada de ventas o una menor actividad promocional, a partir de mayo a junio notamos un aumento de ventas que se puede deber a promociones de verano o el regreso a clases.**"""

# Agrupar por fecha y calcular la venta diaria promedio
# Agrupar por semana o mes para reducir el número de puntos
daily_sales = df_filtro.groupby(pd.Grouper(key='Date', freq='W'))['Sales'].sum()

# Aplicar una media móvil para suavizar las fluctuaciones diarias
daily_sales_smooth = daily_sales.rolling(window=4).mean()

# 6 Gráfico de las ventas semanales
plt.figure(figsize=(14, 7))
plt.plot(daily_sales_smooth, color='b', linestyle='-', linewidth=2, marker='o', markersize=5, markerfacecolor='red', alpha=0.7)
plt.title('Ventas Semanales Promedio desde 2013', fontsize=16, fontweight='bold')
plt.xlabel('Fecha', fontsize=14)
plt.ylabel('Ventas Totales', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.grid(True, linestyle='--', alpha=0.7)

# Ajustar límites del eje x para evitar saturación de etiquetas
plt.xlim(daily_sales_smooth.index.min(), daily_sales_smooth.index.max())

# Mostrar gráfico
plt.tight_layout()
plt.show()

"""**Teniendo en cuenta la evolución semanal de las ventas, confirmamos que los picos entre diciembre y enero se deben a las fechas promocionales como navidad y año nuevo, teniendo unos repuntes hacia final de año pero nos señala un dececrimiento hacia el año 2015, lo que nos puede indicar un cambio en la preferencia de clientes o un cambio en las dinámicas de la competencia.**

"""

# Columnas 'Date', 'Sales', 'Promo2SinceYear', 'PromoInterval'
df_filtro['Date'] = pd.to_datetime(df_filtro['Date'])
df_filtro['Year'] = df_filtro['Date'].dt.year
df_filtro['Month'] = df_filtro['Date'].dt.month

# Filtramos datos a partir del año 2013
df_filtro = df_filtro[df_filtro['Year'] >= 2013]

# Definir si el mes es un mes de promoción
def is_promo_month(row):
    if pd.isna(row['PromoInterval']):
        return 0
    promo_months = {
        'Jan,Apr,Jul,Oct': [1, 4, 7, 10],
        'Feb,May,Aug,Nov': [2, 5, 8, 11],
        'Mar,Jun,Sept,Dec': [3, 6, 9, 12]
    }
    for interval, months in promo_months.items():
        if row['PromoInterval'] == interval and row['Month'] in months:
            return 1
    return 0

# identificar meses de promoción
df_filtro['PromoMonth'] = df_filtro.apply(is_promo_month, axis=1)

# Filtro de tiendas con Promo2 activo desde 2013
df_promo = df_filtro[df_filtro['Promo2SinceYear'] >= 2013]

# Agrupar por meses y PromoMonth para obtener las ventas promedio
monthly_sales = df_promo.groupby(['Year', 'Month', 'PromoMonth'])['Sales'].mean().reset_index()

# Separar datos promocionales de no promocionales
promo_months_sales = monthly_sales[monthly_sales['PromoMonth'] == 1]
non_promo_months_sales = monthly_sales[monthly_sales['PromoMonth'] == 0]

# 7. Gráfica de ventas promedio mensuales en meses de promoción y no promoción
plt.figure(figsize=(10, 6))
plt.plot(promo_months_sales['Month'], promo_months_sales['Sales'], label='Meses con Promo', marker='o')
plt.plot(non_promo_months_sales['Month'], non_promo_months_sales['Sales'], label='Meses sin Promo', marker='o')
plt.xlabel('Mes')
plt.ylabel('Ventas promedio')
plt.title('Ventas promedio mensuales (con y sin promociones)')
plt.legend()
plt.grid(True)
plt.show()

"""**Teniendo en cuenta la exploración anterior se evidencia un impacto en las ventas paro las promociones estacionarias, a nivel general se observan un promedio en las ventas mas alta que en los meses que no hacen uso de ello, esto sugiere que las promociones son útiles para estimular ventas. Sin embargo, la relación entre promociones y ventas no es lineal, ni consistente a lo largo del año lo que indica que no es un factor definitivo para el comportamiento de las ventas**"""

# Calcular el promedio de ventas y la distancia a la competencia por StoreType
df_storetype = df_filtro.groupby('StoreType').agg({'Sales': 'mean', 'CompetitionDistance': 'mean'}).reset_index()

# Mostrar el DataFrame con los promedios
print(df_storetype)
# 8. Scatterplot con el promedio de ventas y distancia a la competencia, clasificado por StoreType
plt.figure(figsize=(10, 6))
sns.scatterplot(x='CompetitionDistance', y='Sales', data=df_storetype, hue='StoreType', s=100, palette='Set1')
plt.title('Promedio de Ventas vs Distancia a la Competencia por Tipo de Tienda')
plt.xlabel('Distancia a la Competencia (Promedio)')
plt.ylabel('Ventas (Promedio)')
plt.grid(True)
plt.legend(title='Tipo de Tienda', loc='upper left', bbox_to_anchor=(1,1))
plt.show()

"""**Tiendas más cercanas a la competencia (B): Tienen las ventas más altas, lo que sugiere que la proximidad a la competencia no siempre es negativa. De hecho, podría ser un factor que impulse el rendimiento, tal vez debido a mayor visibilidad o tráfico de clientes en áreas comerciales concurridas.**

**Tiendas más alejadas de la competencia (A) y (D): Tienen ventas más bajas, lo que sugiere que, en estos casos, estar lejos de la competencia podría no ser tan beneficioso. Estas tiendas podrían tener menos tráfico de clientes o depender más de su lealtad base. Por otro lado la tienda tipo (C) tiene un equilibrio entre ventas y distancia, lo que sugiere que una distancia intermedia también puede ser efectiva, la proximidad a la competencia tiene un impacto importante pero depende del tipo de tienda**

"""

# Agrupar por StoreType, Assortment y calcular el promedio de ventas y la distancia a la competencia
df_storetype_assortment = df_filtro.groupby(['StoreType', 'Assortment']).agg({'Sales': 'mean', 'CompetitionDistance': 'mean'}).reset_index()

# Mostrar el DataFrame con los promedios
print(df_storetype_assortment)
# 9. Scatterplot con el promedio de ventas y distancia a la competencia, clasificado por StoreType y Assortment
plt.figure(figsize=(10, 6))
sns.scatterplot(x='CompetitionDistance', y='Sales', data=df_storetype_assortment, hue='StoreType', style='Assortment', s=100, palette='Set1')
plt.title('Promedio de Ventas vs Distancia a la Competencia por Tipo de Tienda y Surtido')
plt.xlabel('Distancia a la Competencia (Promedio)')
plt.ylabel('Ventas (Promedio)')
plt.grid(True)
plt.legend(title='Tipo de Tienda / Surtido', loc='upper left', bbox_to_anchor=(1,1))
plt.show()

"""**En este grafico buscamos analizar la relación entre el promedio de ventas y la distancia de la competencia, desglosada por el tipo de tienda(A,B,C Y D) y surtido (a,B Y C), observamos que no existe una relación específica entre la distancia de la competencia y las ventas, de hecho se evidencia que las  tiendas más cercanas a la competencia tipo (B) con surtido (A), registran un promedio más alto en ventas, esto indica que una mayor cercanía a los competidores puede estar atrayendo mas clientes o una preferencia del tipo de surtido.
Por otro lado, se evidencia que el surtido juega un papel clave en el rendimiento de las tiendas, debido a que las tiendas B con sutido A y las tipo C con tipo C, destacan en ventas, las tiendas tipo A y D con surtido C, es necesario revisar su oferta para un mejor rendimiento a futuro.**
"""