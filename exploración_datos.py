# -*- coding: utf-8 -*-
"""exploración_datos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YGolDYaRFrCrWG9DeM8ijS33a471rng_
"""

from google.colab import drive
drive.mount('/content/drive')

"""***LIBRERÍAS***"""

#Importar librerias
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

#subir bases de datos
df_train_inicial= pd.read_csv('/content/drive/MyDrive/Modulo final 3 /Bases de datos/train.xlsx - train.csv')
df_store = pd.read_csv('/content/drive/MyDrive/Modulo final 3 /Bases de datos/store_data_modified.csv')

# Reemplazar 'a', 'b', 'c' por 1 y '0' por 0
df_train_inicial['StateHoliday'] = df_train_inicial['StateHoliday'].replace({'a': 1, 'b': 1, 'c': 1, '0': 0})
df_train_inicial.head()

"""- **Para la base Train decidimos hacer una limpieza manual donde eliminamos datos atipicos de los dias que no hubo ventas, siendo en total 54**
- **Se igualaron datos de la columna Promo de 1 a 0 los dias que estuvo cerrada por falta de coherencia**

"""

# Unir los dos DataFrames utilizando la columna 'Store' como clave
df_merged = pd.merge(df_train_inicial, df_store, on='Store', how='left')
df_merged.head()

# Guardar el DataFrame unido como CSV
df_merged.to_csv('bases_unidas.csv', index=False)
from google.colab import files
files.download('bases_unidas.csv')
df_merged.head(10)

"""***BASE DE DATOS***"""

#subir bases de datos
df_train = pd.read_csv('/content/drive/MyDrive/Modulo final 3 /Bases de datos/bases_unidas.csv')
df_Modelo = pd.read_csv('/content/drive/MyDrive/Modulo final 3 /Bases de datos/Modelo_cluster_variable_impacto.csv')
#df_train.head()

df_train.head()

"""***PREPROCESAMIENTO Y LIMPIEZA***"""

#revision de nulos
df_train.isnull().sum()

# Rellenar valores NaN
df_train['StoreType'].fillna(0, inplace=True)
df_train['Assortment'].fillna(0, inplace=True)
df_train['Promo2'].fillna(0, inplace=True)
df_train.head()

# Rellenar valores NaN
df_train['CompetitionDistance'].fillna(df_train['CompetitionDistance'].mean(), inplace=True)
df_train['Promo2SinceWeek'].fillna(0, inplace=True)
df_train['Promo2SinceYear'].fillna(0, inplace=True)
df_train['PromoInterval'].fillna(0, inplace=True)
df_train.head()

"""**Decidimos unir las dos columnas de CompetitionOpenSinceMonth y CompetitionOpenSinceYear, en una sola columna llamada competitionOpenSince  para analizar como la competencia impacta las tiendas en diferentes periodos, facilitando su analisis, para el manejo de datos faltantes se remplazo el 0 por una fecha arbitraria, evitando que nulos o ceros interfieran en un analisis posterior, En el momento decidimos mantenerla como un Placeholder por conveniencia pero el tratamiento de datos faltantets puede ser modificado segun lo necesario**

"""

# Crear la columna 'CompetitionOpenSince' directamente, reemplazando 0 por una fecha arbitraria
if 'CompetitionOpenSinceYear' in df_train.columns and 'CompetitionOpenSinceMonth' in df_train.columns:
    df_train['CompetitionOpenSince'] = df_train.apply(
        lambda row: pd.to_datetime(f"{int(row['CompetitionOpenSinceYear'])}-{int(row['CompetitionOpenSinceMonth'])}", format='%Y-%m', errors='coerce')
        if row['CompetitionOpenSinceYear'] > 0 and row['CompetitionOpenSinceMonth'] > 0
        else pd.Timestamp('2000-01-01'), axis=1
    )

df_train.head()

#definimos la columna Date de forma correcta
df_train['Date'] = pd.to_datetime(df_train['Date'])
df_train.info()
# Convertir la columna a formato 'YYYY-MM'
df_train['CompetitionOpenSince'] = pd.to_datetime(df_train['CompetitionOpenSince'], format='%Y-%m')

# se elimina las columnas 'CompetitionOpenSinceMonth', 'CompetitionOpenSinceYear', debido a la creacion de la columna CompetitionOpenSince y PromoInterval, ya que no la haremos parte de nuestro analisis
df_train.drop(columns=['CompetitionOpenSinceMonth', 'CompetitionOpenSinceYear'], inplace=True)
df_train.head()

"""**Eliminamos las tiendas cerradas ya que no teniamos datos de ventas, que es nuestro objetivo de analisis, filtramos los datos de la competencia a partir del año 2013 por la relevancia en los datos y evitar el ruido de los años anteriores. buscando mejorar la precision del analisis**  """

# Elimnar tiendas cerradas
df_train = df_train[ df_train.Open == 1 ].copy()

# Convertir la columna a formato 'YYYY-MM'
df_train['CompetitionOpenSince'] = pd.to_datetime(df_train['CompetitionOpenSince'], format='%Y-%m')

# Filtrar datos a partir del año 2013
df_filtro = df_train[df_train['CompetitionOpenSince'].dt.year >= 2013]
df_filtro.head()

"""***ANÁLISIS ESTADÍSTICO***"""

#verificacion de columnas
df_filtro.columns

# Scatter plot para ver la relación entre Ventas y Clientes
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Customers', y='Sales', data=df_train, color='red')
plt.title('Relación entre Ventas y Clientes')
plt.xlabel('Clientes')
plt.ylabel('Ventas')
plt.show()

"""**Se evidencia una relacion positiva entres las dos varibles, pero debido a la dispercion se puede decir que existen otros factores que afectan el volumen de ventas.**"""

#Histograma para la variable Ventas (Sales)
plt.figure(figsize=(10, 6))
sns.histplot(df_train['Sales'], bins=30, kde=True, color='blue')
plt.title('Distribución de Ventas')
plt.xlabel('Ventas')
plt.ylabel('Frecuencia')
plt.show()

"""**La grafica campana nos indica una inclinacion hacia la derecha, mostrando asi que la mayoria de ventas se concentran en valores mas bajos, mientras que un menor numero de ventas alcanzan valores mas altos, esto se puede dar por la gestion del mercado como el surtido o las promociones**"""

# Agrupar las ventas totales por día de la semana
sales_by_day = df_train.groupby('DayOfWeek')['Sales'].sum().reset_index()
sns.set(style="whitegrid")
plt.figure(figsize=(10, 6))
sns.barplot(x='DayOfWeek', y='Sales', data=sales_by_day, palette="muted")
plt.title('Ventas Totales por Día de la Semana', fontsize=16, fontweight='bold')
plt.xlabel('Día de la Semana', fontsize=12)
plt.ylabel('Ventas Totales', fontsize=12)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.tight_layout()
plt.show()

"""**Observamos que los dias lunes, martes y viernes se presenta un mayor volumen de ventas, lo que nos puede indicar que los clientes buscan abastecerse para la semana, el dia Domingo muestra menos ventas por que las tiendas no abren todos los domingos solo algunas fechas, teniendo en cuenta los dias mas altos en ventas son los lunes, martes y viernes, se podrian realizar promociones para aprovechar el flujo de clientes, se podria considerar implementar ofertas llamativas para el dia miercoles y jueves y abrir mirar si es viable abrir mas regularmente los dias domingos.**"""

#clientes a lo largo del tiempo por tipo de tienda agrupado por año
sns.set(style="whitegrid")
plt.figure(figsize=(12, 6))
sns.lineplot(x='Date', y='Customers', hue='StoreType', data=df_filtro,
             palette='muted', marker='o', linewidth=2)
plt.title('Clientes a lo largo del tiempo por tipo de tienda', fontsize=16, fontweight='bold')
plt.ylabel('Número de Clientes', fontsize=12)
plt.xlabel('Año', fontsize=12)
plt.xticks(rotation=45)

plt.legend(title='Tipo de Tienda', loc='upper left', bbox_to_anchor=(1, 1))

plt.tight_layout()

"""**Clientes a lo largo del tiempo por tiendas:**
**Se sugiere que el numero de cliente se mantiene estable a lo largo del tiempo, manteniendoce constante, las tiendas parecen tener una segmentacion diferente por lo cual podria atraer un tipo especifico de clientes, la tienda (B) representa un mayor numero de clientes a diferencia de la (A,C Y D ), lo cual nos podria indicar una oportunidad de mejora en su oferta de productos, fidelizacion de clientes u visibilidad en el mercado.**
"""

# Crear una columna de período 'YYYY-MM' para la gráfica
df_filtro['YearMonth'] = df_filtro['Date'].dt.to_period('M')

# Calcular ventas promedio mensual
monthly_sales = df_filtro.groupby('YearMonth')['Sales'].sum()

plt.figure(figsize=(14, 7))
monthly_sales.plot(marker='o')
plt.title('Ventas Totales Mensuales desde 2013')
plt.xlabel('Mes')
plt.ylabel('Ventas Totales')
plt.grid(True)
plt.show()

"""**Se evidencia picos significativos de ventas a inicio de cada año en Enero de 2014 y 2015, esto lo relacionamos a los eventos estacionales como puede ser navidad o año nuevo debido al consumo de esas fechas, despues de estas fecha de alta demanda se nota una estabilizacion de las ventas siendo mas bajos entre Marzo y Abril, lo cual se puede deber a una baja temporada de ventas o una menor actividad promocional, a partir de mayo a junio notamos un aumento de ventas que se puede deber a promociones de verano o el regreso a clases.**"""

# Agrupar por fecha y calcular la venta diaria promedio
# Opción 1: Agrupar por semana o mes para reducir el número de puntos
daily_sales = df_filtro.groupby(pd.Grouper(key='Date', freq='W'))['Sales'].sum()

# Opción 2: Aplicar una media móvil para suavizar las fluctuaciones diarias
daily_sales_smooth = daily_sales.rolling(window=4).mean()

# Crear el gráfico
plt.figure(figsize=(14, 7))
plt.plot(daily_sales_smooth, color='b', linestyle='-', linewidth=2, marker='o', markersize=5, markerfacecolor='red', alpha=0.7)
plt.title('Ventas Semanales Promedio desde 2013', fontsize=16, fontweight='bold')
plt.xlabel('Fecha', fontsize=14)
plt.ylabel('Ventas Totales', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.grid(True, linestyle='--', alpha=0.7)

# Ajustar límites del eje x para evitar saturación de etiquetas
plt.xlim(daily_sales_smooth.index.min(), daily_sales_smooth.index.max())

# Mostrar gráfico
plt.tight_layout()
plt.show()

"""**Teniendo en cuenta la evolucion semanal de las ventas, confirmamos que los picos entre diciembre y enero se deben a las fechas promocionales como navidad y año nuevo, teniendo unos repuntes hacia final de año pero nos señala un dececrimiento hacia el año 2015, lo que nos puede indicar un cambio en la preferencia de clientes o un cambio en las dinamicas de la competencia.**

"""

# Columnas 'Date', 'Sales', 'Promo2SinceYear', 'PromoInterval'
df_filtro['Date'] = pd.to_datetime(df_filtro['Date'])
df_filtro['Year'] = df_filtro['Date'].dt.year
df_filtro['Month'] = df_filtro['Date'].dt.month

# Filtramos datos a partir del año 2013
df_filtro = df_filtro[df_filtro['Year'] >= 2013]

# Definir si el mes es un mes de promoción
def is_promo_month(row):
    if pd.isna(row['PromoInterval']):
        return 0
    promo_months = {
        'Jan,Apr,Jul,Oct': [1, 4, 7, 10],
        'Feb,May,Aug,Nov': [2, 5, 8, 11],
        'Mar,Jun,Sept,Dec': [3, 6, 9, 12]
    }
    for interval, months in promo_months.items():
        if row['PromoInterval'] == interval and row['Month'] in months:
            return 1
    return 0

# identificar meses de promoción
df_filtro['PromoMonth'] = df_filtro.apply(is_promo_month, axis=1)

# Filtro de tiendas con Promo2 activo desde 2013
df_promo = df_filtro[df_filtro['Promo2SinceYear'] >= 2013]

# Agrupar por meses y PromoMonth para obtener las ventas promedio
monthly_sales = df_promo.groupby(['Year', 'Month', 'PromoMonth'])['Sales'].mean().reset_index()

# Separar datos promocionales de no promocionales
promo_months_sales = monthly_sales[monthly_sales['PromoMonth'] == 1]
non_promo_months_sales = monthly_sales[monthly_sales['PromoMonth'] == 0]

# Gráfica de ventas promedio mensuales en meses de promoción y no promoción
plt.figure(figsize=(10, 6))
plt.plot(promo_months_sales['Month'], promo_months_sales['Sales'], label='Meses con Promo', marker='o')
plt.plot(non_promo_months_sales['Month'], non_promo_months_sales['Sales'], label='Meses sin Promo', marker='o')
plt.xlabel('Mes')
plt.ylabel('Ventas promedio')
plt.title('Ventas promedio mensuales (con y sin promociones)')
plt.legend()
plt.grid(True)
plt.show()

"""**Teniendo en cuenta la exploracion anterior se evidencia un impacto en las ventas paro las promociones estacionarias, a nivel general se observan un promedio en las ventas mas alta que en los meses que no hacen uso de ello, esto sugiere que las promociones son utiles para estimular ventas sin embargo la relacion entre promociones y ventas no es lineal, ni consistente a lo largo del año lo que indica que no es un factor definitivo para el comportamiento de las ventas**"""

# Calcular el promedio de ventas y la distancia a la competencia por StoreType
df_storetype = df_filtro.groupby('StoreType').agg({'Sales': 'mean', 'CompetitionDistance': 'mean'}).reset_index()

# Mostrar el DataFrame con los promedios
print(df_storetype)
# Graficar el scatterplot con el promedio de ventas y distancia a la competencia, clasificado por StoreType
plt.figure(figsize=(10, 6))
sns.scatterplot(x='CompetitionDistance', y='Sales', data=df_storetype, hue='StoreType', s=100, palette='Set1')
plt.title('Promedio de Ventas vs Distancia a la Competencia por Tipo de Tienda')
plt.xlabel('Distancia a la Competencia (Promedio)')
plt.ylabel('Ventas (Promedio)')
plt.grid(True)
plt.legend(title='Tipo de Tienda', loc='upper left', bbox_to_anchor=(1,1))
plt.show()

"""**Tiendas más cercanas a la competencia (B): Tienen las ventas más altas, lo que sugiere que la proximidad a la competencia no siempre es negativa. De hecho, podría ser un factor que impulse el rendimiento, tal vez debido a mayor visibilidad o tráfico de clientes en áreas comerciales concurridas.**

**Tiendas más alejadas de la competencia (A) y (D): Tienen ventas más bajas, lo que sugiere que, en estos casos, estar lejos de la competencia podría no ser tan beneficioso. Estas tiendas podrían tener menos tráfico de clientes o depender más de su lealtad base. Por otro lado la tienda tipo (C) tiene un equilibrio entre ventas y distancia, lo que sugiere que una distancia intermedia también puede ser efectiva, la proximidad a la competencia tiene un impacto importante pero depende del tipo de tienda**

"""

# Agrupar por StoreType, Assortment y calcular el promedio de ventas y la distancia a la competencia
df_storetype_assortment = df_filtro.groupby(['StoreType', 'Assortment']).agg({'Sales': 'mean', 'CompetitionDistance': 'mean'}).reset_index()

# Mostrar el DataFrame con los promedios
print(df_storetype_assortment)
# Graficar el scatterplot con el promedio de ventas y distancia a la competencia, clasificado por StoreType y Assortment
plt.figure(figsize=(10, 6))
sns.scatterplot(x='CompetitionDistance', y='Sales', data=df_storetype_assortment, hue='StoreType', style='Assortment', s=100, palette='Set1')
plt.title('Promedio de Ventas vs Distancia a la Competencia por Tipo de Tienda y Surtido')
plt.xlabel('Distancia a la Competencia (Promedio)')
plt.ylabel('Ventas (Promedio)')
plt.grid(True)
plt.legend(title='Tipo de Tienda / Surtido', loc='upper left', bbox_to_anchor=(1,1))
plt.show()

"""**En este grafico buscamos analizar la relacion entre el promedio de ventas y la distancia de la competencia, desglosada por el tipo de tienda(A,B,C Y D) y surtido (a,B Y C), observamos que no existe una relacion especifica entre la distancia de la competencia y las ventas, de hecho se evidencia que las  tiendas mas cercanas a la competencia tipo (B) con surtido (A), registran un promedio mas alto en ventas, esto indica que una mayor cercania a los competidores puede estar atrayendo mas clientes o una preferencia del tipo de surtido.
Por otro lado se evidencia que el surtido juega un papel clave en el rendimiento de las tiendas, debido a que las tiendas B con sutido A y las tipo C con tipo C, destacan en ventas, las tiendas tipo A y D con surtido C, es necesario revisar  su oferta para un mejor rendimiento a futuro.**
"""

plt.figure(figsize=(10, 6))
sns.barplot(x='Etiqueta_Cluster', y='CompetitionDistance', data=df_Modelo, palette='coolwarm')
plt.title('Distancia a la Competencia según Cluster')
plt.xlabel('Cluster')
plt.ylabel('Distancia a la Competencia')
plt.show()

"""**Las tiendas que están más alejadas de la competencia (Cluster Alto) tienen una situación particular. Aunque podría parecer que tener menos competidores cercanos es beneficioso, estas tiendas tienen menos ventas. Esto puede deberse a que la falta de competencia también significa menos demanda en esas áreas o menor afluencia de clientes. En contraste, las tiendas en el Cluster Bajo están en áreas altamente competitivas pero pueden estar beneficiándose de un tráfico de clientes.**

"""

plt.figure(figsize=(10, 6))
sns.lineplot(x='MonthsSinceCompetition', y='SalesPerCustomer', hue='Etiqueta_Cluster', data=df_Modelo, marker='o', palette='Set1')
plt.title('Tendencia de Ventas por Cliente según Meses desde Competencia y Cluster')
plt.xlabel('Meses desde Competencia')
plt.ylabel('Ventas por Cliente')
plt.show()

"""**Teniendo en cuenta el análisis exploratorio con la variable de impacto, determinamos que el cluster alto experimenta un impacto negativo en términos de ventas cuando puede aparecer una nueva competencia, esto puede indicar que las tiendas más alejadas pueden tener problemas para enfrentarse a la llegada de nuevos competidores.**

**El cluster medio y bajo, indica menos variación en las ventas, lo  que demuestra que estan mejor preparadas para la competencia aplicando promociones o teniendo en cuenta el surtido y fidelización de clientes**

**Recomendaciones según exploración de datos:**
- Las tiendas ubicadas en el cluster alto podrían implementar estartegias de marketing para atraer más clientes que incentiven a la visita de la tiendas, teniendo en cuenta que al parecer no son tiendas que se encuentren en zonas concurridas la oferta sea llamativa o el tipo de surtido
- Diversificar el surtido teniendo en cuenta la demanda de la región
- Tener en cuenta festividades especificas para futuras promociones.

 **Cluster medio y bajo:**
- Ofrecer programas de fidelizacion que recompensen a los clientes recurrentes
- Evaluar la calidad de servicio y experencia de compra que nos permita mejorar la calidad del servicio
- Ya que se evidencio una diferencia en las ventas por surtido se podría estudiar la personalización del surtido y la demanda local, lo cual podría mejorar el rendimiento de las tiendas
- A las tiendas que tienen una audiencia significativa y ventas mas estables se podria brindar servicios que mejoren la experiencia de compra, ya sea en línea o promociones más personalizadas.
"""