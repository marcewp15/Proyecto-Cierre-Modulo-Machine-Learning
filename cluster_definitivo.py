# -*- coding: utf-8 -*-
"""cluster_definitivo

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17EUcph5xoXPRU-C0kED4r11BzO4VIzuy

# **Modelo Cluster no-supervisado**

# **Importar librerias.**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import MinMaxScaler
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler

# Cargar los conjuntos de datos


# cargar datos
merged_df =pd.read_csv('/content/bases_unidas .csv')

#Limpieza y manipulación de datos


# Crear nuevas características
# Calcular las ventas promedio por cliente
merged_df['SalesPerCustomer'] = merged_df['Sales'] / merged_df['Customers']

# Crear la característica 'MonthsSinceCompetition' asegurando que no haya valores negativos
merged_df['MonthsSinceCompetition'] = (merged_df['Date'].apply(lambda x: int(x[:4])) - merged_df['CompetitionOpenSinceYear']) * 12 + \
                                      (merged_df['Date'].apply(lambda x: int(x[5:7])) - merged_df['CompetitionOpenSinceMonth'])

# Establecer los valores negativos a cero, lo que significa que la competencia no ha comenzado aún
merged_df['MonthsSinceCompetition'] = merged_df['MonthsSinceCompetition'].apply(lambda x: max(x, 0))

# Manejar los valores faltantes en MonthsSinceCompetition
merged_df['MonthsSinceCompetition'].fillna(0, inplace=True)

# Manejar los valores faltantes en CompetitionDistance
merged_df['CompetitionDistance'].fillna(merged_df['CompetitionDistance'].max(), inplace=True)

# Agregar los datos para obtener un resumen a nivel de tienda
store_summary = merged_df.groupby('Store').agg({
    'Sales': 'mean',
    'Customers': 'mean',
    'SalesPerCustomer': 'mean',
    'CompetitionDistance': 'mean',
    'MonthsSinceCompetition': 'mean'
}).reset_index()

# Mostrar las primeras filas del resumen agregado de tiendas
store_summary

"""# **Correlacion de las variables.**"""

# Definir el número de clusters (3 niveles)
num_clusters = 3

# Seleccionar las características para el clustering
X = store_summary[[ 'SalesPerCustomer', 'CompetitionDistance', 'MonthsSinceCompetition']]



# Calcular la correlación entre las ventas y las características relacionadas con la competencia
correlation_sales_competition = store_summary[['Sales', 'CompetitionDistance', 'MonthsSinceCompetition']].corr()

correlation_sales_competition

"""# **Estandarizar datos y aplicar modelo.**"""

#estandarizar datos
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

kmeans = KMeans(n_clusters=num_clusters, random_state=42)
kmeans.fit(X_scaled)

# Agregar las etiquetas de cluster al DataFrame
X['Cluster'] = kmeans.labels_

X

# Aplicar PCA para reducir la dimensionalidad
#pca = PCA(n_components=2)
#X_pca = pca.fit_transform(X_scaled)

"""# **Calcular Coeficiente de silueta.**"""

# Calcular el coeficiente de silueta
silhouette_avg = silhouette_score(X_scaled, kmeans.labels_)
print(f'Coeficiente de silueta: {silhouette_avg:.4f}')
print(f'Inercia: {kmeans.inertia_}')

"""# **Graficar inercia, metodo del codo.**"""

#graficando inercia para metodo del codo
inercias = []
for k in range(2, 10):
    kmeans = KMeans(n_clusters=k, random_state =42)
    kmeans.fit(X_scaled)
    inercias.append(kmeans.inertia_)

plt.figure(figsize=(6, 5), dpi=100)
plt.scatter(range(2, 10), inercias, marker="o", s=180, color="purple")
plt.xlabel("Número de Clusters", fontsize=25)
plt.ylabel("Inercia", fontsize=25)
plt.show()

"""# **Visualizacion de los cluster, usando PCA.**"""

# Separar las características de los clusters con grafico PCA
features = X.drop('Cluster', axis=1)
clusters = X['Cluster']

# Normalizar los datos
scaler = StandardScaler()
X_scaled = scaler.fit_transform(features)

# Aplicar PCA para reducir a 2 dimensiones
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

# Crear un DataFrame con los componentes principales
pca_df = pd.DataFrame(data=X_pca, columns=['PCA1', 'PCA2'])
pca_df['Cluster'] = clusters

# Crear el gráfico de dispersión
plt.figure(figsize=(10, 7))
scatter = plt.scatter(pca_df['PCA1'], pca_df['PCA2'], c=pca_df['Cluster'], cmap='viridis')
plt.colorbar(scatter, label='Cluster')
plt.title('PCA Visualization of Clusters')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid(True)
plt.show()

"""# **Agrupar y ver estadistica de los cluster.**"""

#agrupar y ver estdistica de los cluster
cluster_analysis = X.groupby('Cluster').agg({
    'SalesPerCustomer': ['mean', 'median'],
    'CompetitionDistance': ['mean', 'median'],
    'MonthsSinceCompetition': ['mean', 'median']
})

cluster_analysis

"""# **Etiquetando los diferentes cluster.**"""

'''
vamos a identificar la variable impacto que para este caso la llamaremos etiqueta cluster y se dividirá en los siguientes parametros:

 Cluster 2 (Bajo): Este cluster tiene el promedio más alto en VentasPorCliente (11.36) y DistanciaDeLaCompetencia (9096.87). Esto indica que las tiendas en este grupo tienen un buen rendimiento en ventas a pesar de tener la competencia relativamente lejos. Por lo tanto, se les podría considerar como de "bajo" impacto por la competencia.

Cluster 0 (Medio): Este cluster muestra el promedio más alto en MesesDesdeQueAbrióLaCompetencia (115.98). Aunque no tenemos información directa sobre las ventas o la distancia a la competencia para este cluster en específico, podríamos inferir que representa un nivel "medio" de impacto. Quizás estas tiendas han tenido más tiempo para adaptarse a la presencia de la competencia.

Cluster 1 (Alto): Este cluster tiene los promedios más bajos en VentasPorCliente (8.15) y DistanciaDeLaCompetencia (2747.26). Esto sugiere que las tiendas en este grupo tienen ventas más bajas y la competencia más cerca, lo que podría indicar un "alto" impacto de la competencia en su rendimiento.
'''
etiquetas_cluster = {
    0: 'Medio',
    1: 'Alto',
    2: 'Bajo'
}

# Agrega una nueva columna 'Etiqueta_Cluster' al DataFrame
X['Etiqueta_Cluster'] = X['Cluster'].map(etiquetas_cluster)

# Muestra el DataFrame actualizado
X

from google.colab import files

# Guardar el DataFrame X en un archivo CSV
X.to_csv('X_modificado.csv', index=False)

# Descargar el archivo CSV
files.download('X_modificado.csv')

"""Recomendaciones!
Clúster "Alto":

Estrategia: Aquí debemos ser más agresivos. Las tiendas en este grupo tienen ventas más bajas y la competencia está más cerca.
Considera:
Promociones y descuentos: Para atraer clientes y aumentar las ventas.

Programas de fidelización: Para retener a los clientes existentes.

Análisis de la competencia: Identifica los puntos fuertes y débiles de tus competidores para ajustar tu estrategia.
Mejorar la experiencia del cliente: Ofrece un servicio al cliente excepcional y crea un ambiente de compra agradable.

Clúster "Medio":

Estrategia: Este grupo representa un nivel medio de impacto de la competencia.
Considera:
Optimizar la estrategia actual: Analiza qué está funcionando y qué no.

Enfoque en la diferenciación: Destaca los aspectos que hacen que tus tiendas sean únicas.

Marketing dirigido: Dirígete a clientes específicos con ofertas personalizadas.

Clúster "Bajo":

Estrategia: Estas tiendas tienen un buen rendimiento a pesar de la competencia.
Considera:
Mantener la estrategia actual: Si está funcionando, no la cambies drásticamente.

Buscar oportunidades de crecimiento: Explora nuevas formas de aumentar las ventas, como la expansión a nuevos mercados o la introducción de nuevos productos.

Monitorizar la competencia: Aunque el impacto es bajo, es importante estar al tanto de los movimientos de la competencia.
"""